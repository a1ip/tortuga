### Что такое неймспейсы и зачем они?

Неймспейсы нужны затем же, зачем и во всех остальных языках. Чтобы разрграничить пространства имён классов, функций, объектов и прочих переменных.

Описание наших неймспейсов лежит в файлике /www-public/js/Helper.js


### Где первоначальный код, а где то, что его использует?

Первоначальный код в index.html. Там в функции init() из веб-страницы
по идентификаторам берутся нужные блоки, которые будут
задействованы в работе программы.

Эти блоки передаются в функции инициализации приложения:
* *Tortuga.initApp()* из файла *tortuga.js*
* *Tortuga.initHelp()* из файла *help.js*

Там создаются нужные данные, вспомогательные html-элементы, 
на элементы навешиваются разные обработчики событий, 
ну и вообще, всё опутывается некоторой логикой, распределённой по разным файлам.

**Общая структура каждого файла**

В общих чертах каждый файл выглядит так:

    ns("Tortuga.Vm");

    var createTortoise;
    var clearCanvas;
    var repeat;
    var begin;
    var end;
    Tortuga.Vm.initTortoise;

    (function(){
    	var fun1 = ....
    	var fun2 = ....

    	....

    	createTortoise = function(param)
    	{
    		return fun1(fun2(param));
    	}

    	Tortuga.Vm.initTortoise = function(){...}
    })()

Большую часть файла занимает тело анонимной функции,
которая вызывает себя сразу же после своего объявления.
Как это работает, должно быть понятно на примере:

    (function(x){console.log(x * x)})(2)

Внутри этой функции создаются какие-то локальные переменные (fun1, fun2),
а также могут создаваться и изменятья объекты из глобальной области видимости
(createTortoise, Tortuga.Vm.initTortoise).

Создаваемые глобальные объекты мы для удобства перечисляем вначале файла.
Они потом будут доступны из другого кода и из консоли.

Локальные переменные не будут видны извне, но они не погибают сразу после выполнения
анонимной функции. К ним есть опосредованный доступ через глобальные объекты.

Так, например, функция fun1() из кусочка выше
вызывается внутри вызова функции createTortoise(),
хотя непосредственно к ней обратиться снаружи никак нельзя.

Так мы добиваемся сокрытия внутренней структуры модулией 
и ограничиваем интерфейс взаимодействия с модулем.
